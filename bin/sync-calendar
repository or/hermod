#!/usr/bin/env python3
import argparse
import os
import os.path
from dateutil.parser import parse
from dateutil.rrule import rrulestr, rruleset
from dateutil.tz import tzlocal, tzutc
from datetime import datetime, date, timedelta
from glob import glob
from icalendar import Calendar
from PyOrgMode import PyOrgMode

ORG_TIME_FORMAT = "%Y-%m-%d %a %H:%M"
CALENDARS_PATH = "~/Library/Calendars"
ORG_CALENDAR_PATH = "~/org"

ORG_CALENDAR_PATH = os.path.expanduser(ORG_CALENDAR_PATH)
CALENDARS_PATH = os.path.expanduser(CALENDARS_PATH)

def get_events(cal):
    for component in cal.walk():
        if component.name == "VEVENT":
            yield component


def load_events(directory):
    entries = {}
    for filename in glob(directory + "/**/*.ics", recursive=True):
        statinfo = os.stat(filename)
        if statinfo.st_size > 1024 * 1024:
            continue

        ics_data = open(filename, "rb").read()
        cal = Calendar.from_ical(ics_data)

        # going through all events will make sure the latest version
        # of it will make it into entries, but we need to sort them, as
        # the order is not guaranteed to be chronological
        # TODO: this still doesn't feel ideal - what's the right way to
        # consolidate the same event UID across multiple files?
        for event in sorted(get_events(cal), key=lambda e: e.get("dtstart").dt):
            uid = event.get("uid")
            if uid not in entries:
                entries[uid] = (filename, [event])
            else:
                entries[uid][1].append(event)

    return entries


def escape_brackets(s):
    if not s:
        return s

    return s.replace("[", r"\[").replace("]", r"\]")


def remove_brackets(s):
    if not s:
        return s

    return s.replace("[", "").replace("]", "")


def fix_address(s):
    if not s:
        return s

    return "[[{}][{}]]".format(s, s.replace("mailto:", ""))


def fix_title(s):
    if not s:
        return s

    s = remove_brackets(s)

    MAX_LENGTH = 50
    if len(s) > MAX_LENGTH:
        s = s[:MAX_LENGTH - 3] + "..."

    return s


def create_element(events, filename):
    start = None
    end = None
    rrule_string = None
    exceptions = []
    reschedules = []
    for event in events:
        new_start = event.get("dtstart").dt
        new_end = event.get("dtend").dt
        if not start or new_start < start:
            start = new_start

        if not end or new_end < end:
            end = new_end

        new_rrule_string = event.get("rrule")
        if rrule_string is None and new_rrule_string:
            rrule_string = new_rrule_string

        exdates = event.get('exdate', [])
        if isinstance(exdates, list):
            exceptions += exdates
        else:
            exceptions.append(exdates)

        recurrence_id = event.get("recurrence-id")
        if recurrence_id:
            reschedules.append((
                parse(recurrence_id.to_ical()).astimezone(tzlocal()),
                parse(event.get("dtstart").to_ical()).astimezone(tzlocal()),
            ))

    if not isinstance(start, datetime):
        start = datetime(start.year, start.month, start.day, 0, 0, 0,
                         tzinfo=tzlocal())

    if not isinstance(end, datetime):
        end = datetime(end.year, end.month, end.day, 0, 0, 0,
                       tzinfo=tzlocal())

    start = start.astimezone(tzlocal())
    end = end.astimezone(tzlocal())

    duration = end - start

    if rrule_string:
        if 'UNTIL' in rrule_string:
            # UNTIL dates in the RRULE string must be UTC, sometimes that doesn't
            # seem to be specified in the .ics file, so make sure we convert
            # it in that case
            until = rrule_string['UNTIL']
            for i in range(len(until)):
                d = until[i]
                if isinstance(d, date):
                    until[i] = datetime(d.year, d.month, d.day, 23, 59, 59,
                                        tzinfo=tzutc())
                elif not d.tzinfo:
                    until[i] = d.astimezone(tzutc())

        ruleset = rruleset()
        ruleset.rrule(
            rrulestr(
                rrule_string.to_ical().decode("ascii"),
                dtstart=start))

        for exdate in exceptions:
            t = parse(exdate.to_ical()).astimezone(tzlocal())
            ruleset.exdate(t)

        times = list(ruleset.between(after=MIN_TIME, before=MAX_TIME))
    else:
        times = []
        if MIN_TIME <= start <= MAX_TIME:
            times.append(start)

    if not times:
        return

    for i in range(len(times)):
        start = times[i]
        for planned_start, new_start in reschedules:
            if start == planned_start:
                times[i] = new_start
                break

    element = PyOrgMode.OrgNode.Element()
    element.level = 1
    element.heading = "[[{}][{}]]" \
           .format(filename, fix_title(event.get("summary")))

    drawer = PyOrgMode.OrgDrawer.Element("SCHEDULE")
    element.append_clean(drawer)

    index = 0
    for t1 in times:
        remaining_duration = timedelta(days=duration.days,
                                       seconds=duration.seconds)
        while t1.date() != (t1 + remaining_duration).date():
            next_day = t1 + timedelta(days=1)
            next_day = datetime(next_day.year, next_day.month, next_day.day,
                                tzinfo=next_day.tzinfo)
            t2 = next_day - timedelta(seconds=1)
            if t1 == t2:
                break

            index += 1
            drawer.append("<{start}>--<{end}>"
                          .format(start=t1.strftime(ORG_TIME_FORMAT),
                                  end=t2.strftime(ORG_TIME_FORMAT)))
            remaining_duration -= next_day - t1
            t1 = next_day

        if remaining_duration:
            t2 = t1 + remaining_duration
            index += 1
            drawer.append("<{start}>--<{end}>"
                          .format(start=t1.strftime(ORG_TIME_FORMAT),
                                  end=t2.strftime(ORG_TIME_FORMAT)))

    return element


def add_events(org_data, events, filename):
    element = create_element(events, filename)
    if element:
        org_data.root.append_clean(element)
        org_data.root.append_clean("\n")


def import_to_org(output_path):
    calendar_file = output_path
    entries = load_events(CALENDARS_PATH)

    org_data = PyOrgMode.OrgDataStructure()
    org_data.root.append_clean("#+FILETAGS: :calendar:\n\n")
    for filename, events in entries.values():
        add_events(org_data, events, filename)

    open(calendar_file, "w", encoding="utf-8").write(str(org_data.root))

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--output", "-o",
                        default=os.path.join(ORG_CALENDAR_PATH, "calendar.org"),
                        help="the file to write to")
    parser.add_argument("--num-days-back", default=31, type=int,
                        help="the number of days to generate events for in hindsight")

    args = parser.parse_args()

    MIN_TIME = datetime.now(tzlocal()) - timedelta(days=args.num_days_back)
    MAX_TIME = datetime.now(tzlocal()) + timedelta(days=31)

    import_to_org(args.output)
