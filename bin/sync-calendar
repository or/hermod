#!/usr/bin/env python3
import os.path
import re
import sys
from dateutil.rrule import rrulestr
from dateutil.tz import tzlocal
from datetime import datetime, date, timedelta
from glob import glob
from icalendar import Calendar
from PyOrgMode import PyOrgMode

num_days_back = 31
if len(sys.argv) > 1:
    num_days_back = int(sys.argv[1])

BLANK_LINES = re.compile(r'(\n *)(\n *)+', re.MULTILINE)
TRAILING_SPACES = re.compile(r' +(?=\n)', re.MULTILINE)
WRAP_AT_80 = re.compile(r'(?<=\n[^\n]{80})(?=[^\n]{10})', re.MULTILINE)
TRAILING_NEWLINES = re.compile(r'[ \n]+$', re.MULTILINE)
ORG_TIME_FORMAT = "%Y-%m-%d %a %H:%M"
CALENDARS_PATH = "~/Library/Calendars"
ORG_CALENDAR_PATH = "~/org"

ORG_CALENDAR_PATH = os.path.expanduser(ORG_CALENDAR_PATH)
CALENDARS_PATH = os.path.expanduser(CALENDARS_PATH)

MIN_TIME = datetime.now(tzlocal()) - timedelta(days=num_days_back)
MAX_TIME = datetime.now(tzlocal()) + timedelta(days=31)


def get_events(cal):
    for component in cal.walk():
        if component.name == "VEVENT":
            yield component


def load_events(directory):
    entries = {}
    for filename in glob(directory + "/**/*.ics", recursive=True):
        ics_data = open(filename, "rb").read()
        cal = Calendar.from_ical(ics_data)
        # going through all events will make sure the latest version
        # of it will make it into entries
        for event in get_events(cal):
            start = event.get("dtstart")
            d = start.dt
            if isinstance(d, date):
                d = datetime(d.year, d.month, d.day)

            uid = event.get("uid")
            if uid not in entries:
                entries[uid] = (filename, event)
            else:
                # update the event with the changes
                entries[uid][1].update(event)

    return entries


def escape_brackets(s):
    if not s:
        return s

    return s.replace("[", r"\[").replace("]", r"\]")


def remove_brackets(s):
    if not s:
        return s

    return s.replace("[", "").replace("]", "")


def fix_address(s):
    if not s:
        return s

    return "[[{}][{}]]".format(s, s.replace("mailto:", ""))


def fix_title(s):
    if not s:
        return s

    s = remove_brackets(s)

    MAX_LENGTH = 50
    if len(s) > MAX_LENGTH:
        s = s[:MAX_LENGTH - 3] + "..."

    return s


def create_element(event, filename):
    start = event.get("dtstart").dt
    end = event.get("dtend").dt
    if not isinstance(start, datetime):
        start = datetime(start.year, start.month, start.day, 0, 0, 0,
                         tzinfo=tzlocal())
    if not isinstance(end, datetime):
        end = datetime(end.year, end.month, end.day, 0, 0, 0,
                       tzinfo=tzlocal())

    start = start.astimezone(tzlocal())
    end = end.astimezone(tzlocal())

    duration = end - start

    rrule_string = event.get("rrule")
    if rrule_string:
        rrule = rrulestr(rrule_string.to_ical().decode("ascii"),
                         dtstart=start)
        times = list(rrule.between(after=MIN_TIME, before=MAX_TIME))
    else:
        times = []
        if MIN_TIME <= start <= MAX_TIME:
            times.append(start)

    if not times:
        return

    element = PyOrgMode.OrgNode.Element()
    element.level = 1
    element.heading = "[[{}][{}]]" \
           .format(filename, fix_title(event.get("summary")))

    drawer = PyOrgMode.OrgDrawer.Element("SCHEDULE")
    element.append_clean(drawer)

    index = 0
    for t1 in times:
        remaining_duration = timedelta(days=duration.days,
                                       seconds=duration.seconds)
        while t1.date() != (t1 + remaining_duration).date():
            next_day = t1 + timedelta(days=1)
            next_day = datetime(next_day.year, next_day.month, next_day.day,
                                tzinfo=next_day.tzinfo)
            t2 = next_day - timedelta(seconds=1)
            if t1 == t2:
                break

            index += 1
            drawer.append("<{start}>--<{end}>"
                          .format(start=t1.strftime(ORG_TIME_FORMAT),
                                  end=t2.strftime(ORG_TIME_FORMAT)))
            remaining_duration -= next_day - t1
            t1 = next_day

        if remaining_duration:
            t2 = t1 + remaining_duration
            index += 1
            drawer.append("<{start}>--<{end}>"
                          .format(start=t1.strftime(ORG_TIME_FORMAT),
                                  end=t2.strftime(ORG_TIME_FORMAT)))

    return element


def add_event(org_data, event, filename):
    element = create_element(event, filename)
    if element:
        org_data.root.append_clean(element)
        org_data.root.append_clean("\n")


def import_to_org():
    calendar_file = os.path.join(ORG_CALENDAR_PATH, "calendar.org")
    entries = load_events(CALENDARS_PATH)

    org_data = PyOrgMode.OrgDataStructure()
    org_data.root.append_clean("#+FILETAGS: :calendar:\n\n")
    for filename, event in entries.values():
        add_event(org_data, event, filename)

    open(calendar_file, "w", encoding="utf-8").write(str(org_data.root))

if __name__ == "__main__":
    import_to_org()
